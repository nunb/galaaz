---
title: "Non Standard Evaluation in dplyr with Galaaz"
author:
    - "Rodrigo Botafogo"
    - "Daniel Mossé - University of Pittsburgh"
tags: [Tech, Data Science, Ruby, R, GraalVM]
date: "20/02/2019"
output:
  html_document:
    self_contained: true
    keep_md: true
  pdf_document:
    includes:
      in_header: ["../../sty/galaaz.sty"]
    number_sections: yes
---

```{r setup, echo=FALSE, message = FALSE}
library('dplyr')
library('tibble')
```

# Introduction

```{r tibble}
df <- data.frame(x = 1:3, y = 3:1)
print(df)

print(filter(df, x == 1))
#> # A tibble: 1 x 2
#>       x     y
#>   <int> <int>
#> 1     1     3
```

```{r my_var_err, eval = FALSE}
my_var <- x
#> Error in eval(expr, envir, enclos): object 'x' not found
filter(df, my_var == 1)
#> Error: object 'my_var' not found
```

# Writing Expressions in Galaaz

Galaaz extends Ruby to work with complex expressions, similar to R's expressions build with 'quote' 
(base R) or 'quo' (tidyverse).  Let's take a look at some of those expressions.  

## Expressions from operators

The code bellow 
creates an expression summing two symbols

```{ruby expressions}
exp1 = :a + :b
puts exp1
```

We can build any complex mathematical expression

```{ruby expr2}
exp2 = (:a + :b) * 2.0 + :c ** 2 / :z
puts exp2
```

It is also possible to use inequality operators in building expressions

```{ruby expr3}
exp3 = (:a + :b) >= :z
puts exp3
```

Galaaz provides both symbolic representations for operators, such as (>, <, !=) as functional 
notation for those operators such as (.gt, .ge, etc.).  So the same expression written 
above can also be written as

```{ruby expr4}
exp4 = (:a + :b).ge :z
puts exp4
```

Two type of expression can only be created with the functional representation of the operators, 
those are expressions involving '==', and '='.  In order to write an expression involving '==' we
need to use the method '.eq' and for '=' we need the function '.assign'

```{ruby expr5}
exp5 = (:a + :b).eq :z
puts exp5
```

```{ruby expr6}
exp6 = :y.assign :a + :b
puts exp6
```
In general we think that using the functional notation is preferable to using the symbolic notation
as otherwise, we end up writing invalida expressions such as

```{ruby exp_wrong}
exp_wrong = (:a + :b) == :z
puts exp_wrong
```
and it might be difficult to understand what is going on here.  The problem lies with the fact that
when using '==' we are comparing expression (:a + :b) to expression :z with '=='.  When the 
comparison is executed, the system tries to evaluate :a, :b and :z, and those symbols, at 
this time are not bound to anything and we get a "object 'a' not found" message.  
If we only use functional notation, this type of error will never occur.

## Expressions with R methods

It is often necessary to create an expression that uses a method or function.  For instance, in
mathematics, it's quite natural to write an expressin such as $y = sin(x)$. In this case, the
'sin' function is part of the expression and should not immediately executed. Now, let's say
that 'x' is an angle of 45$^\circ$ and we acttually want our expression to be $y = 0.850...$.
When we want the function to be part of the expression, we call the function preceeding it
by the letter E, such as 'E.sin(x)'

```{ruby method_expression}
exp7 = :y.assign E.sin(:x)
puts exp7
```
However, if we want the function to be evaluated, then
we use the normal call to function with R as 'R.sin(x)'.

```{ruby method_exc}
x = 45
exp8 = :y.assign R.sin(x)
puts exp8
```
# Filtering using expressions

Now that we now how to write expression, we can use then to filter a data frame by expressions.  
Let's first start by creating a simple data frame with two columns named 'x' and 'y'

```{ruby df}
@df = R.data__frame(x: (1..3), y: (3..1))
puts @df
```
In the code bellow we want to filter the data frame by rows in which the value of 'x' is
equal to 1.

```{ruby filter_exp}
puts @df.filter(:x.eq 1)
```

In R, and when coding with 'tidyverse', arguments to a function are usually not 
*referencially transparent*. That is, ou can’t replace a value with a seemingly equivalent 
object that you’ve defined elsewhere. In other words, this code

```{r not_transp, eval=FALSE}
my_var <- x
filter(df, my_var == 1)
```
Generates the following error: "object 'x' not found.

However, in Ruby and Galaaz, arguments are referencially transparent as can be seen by the 
code bellow.  Note, initally that 'my_var = :x' will not give the error "object 'x' not found" 
since ':x' is treated as an expression and assigned to my\_var. Then when doing (my\_var.eq 1), 
my\_var is a variable that resolves to ':x' and it becomes equivalent to (:x.eq 1) which is
what we want.

```{ruby my_var}
my_var = :x
puts @df.filter(my_var.eq 1)
```
As stated by Hardley

> dplyr code is ambiguous. Depending on what variables are defined where, 
> filter(df, x == y) could be equivalent to any of:

```
df[df$x == df$y, ]
df[df$x == y, ]
df[x == df$y, ]
df[x == y, ]
```
In galaaz this ambiguity does not exist, filter(df, x.eq y) is not a valid expression as 
expressions are build with symbols.  In doing filter(df, :x.eq y) we are looking for elements
of the 'x' column that are equal to a previously defined y variable.  Finally, 
filter(df, :x.eq :y) we are looking for elements in which the 'x' column value is equal to
the 'y' column value. This can be seen in the following two chunks of code:

```{ruby disamb1}
@y = 1
@x = 2

# looking for values where the 'x' column is equal to the 'y' column
puts @df.filter(:x.eq :y)
```

```{ruby disamb2}
# looking for values where the 'x' column is equal to the 'y' variable
# in this case, the number 1
puts @df.filter(:x.eq @y)
```
# Writing a function that applies to different data sets



```
mutate(df1, y = a + x)
mutate(df2, y = a + x)
mutate(df3, y = a + x)
mutate(df4, y = a + x)
```

Here we create a mutate_y Ruby method.

```{ruby mutate_y}
def mutate_y(df)
  df.mutate(:y.assign :a + :x)
end
```

Note that contrary to what happens in R, method mutate_y will fail independetly from the fact
that variable 'a' is defined or not.

```{ruby call_mutate}
df1 = R.data__frame(x: (1..3))
puts df1
a = 10
mutate_y(df1)
```

# Different expressions

```{r diff_expr}
df <- data.frame(
  g1 = c(1, 1, 2, 2, 2),
  g2 = c(1, 2, 1, 2, 1),
  a = sample(5),
  b = sample(5)
)

d2 <- df %>%
  group_by(g1) %>%
  summarise(a = mean(a))
	       
as.data.frame(d2)	       

d2 <- df %>%
  group_by(g2) %>%
  summarise(a = mean(a))
	       
as.data.frame(d2)	       
```

Trying to write a function in R that will receive two argumens, the first a variable and
the second an expression is not trivia. As shown by Hardley, one might expect this function 
to do the trick:

```{r diff_exp_fnc}
my_summarise <- function(df, group_var) {
  df %>%
    group_by(group_var) %>%
    summarise(a = mean(a))
}

# my_summarise(df, g1)
#> Error: Column `group_var` is unknown
```

In order to solve this problem, coding with dplyr requires the introduction of many new concepts
and functions such as 'quo', 'quos', 'enquo', 'enquos', '!!' (bang bang), '!!!' (triple bang).

Now, let's try to implement the same function in galaaz.  The next code block first prints the
'df' data frame define previously in R, then creates the my_summarize function and calls it 
passing the R data frame and the group by variable ':g1'

```{ruby diff_exp_ruby_func}
puts ~:df
print "\n"

def my_summarize(df, group_var)
  df.group_by(group_var).
    summarize(a: E.mean(:a))
end

puts my_summarize((~:df), :g1).as__data__frame
```
It works!!! Well let's make sure this was not just some coincidence

```{ruby group_g2}
puts my_summarize((~:df), :g2).as__data__frame
```

Great, everything is fine! No magic, no new functions, no complexities, just normal, standard Ruby
code.  If you've ever done NSE in R, this certainly feels much safer and easy to implement.

# Different input variables

In the previous section we've managed to get rid of all NSE formulation for a simple example, but
does this remain true for more complex examples, or will the Ruby way prove inpractical for
more complex code?

In the next example Hardley proposes us to write a function that given an expression such as 'a'
or 'a * b', calculates three summaries.  What we want a function that does the same as these R
statements:

```
summarise(df, mean = mean(a), sum = sum(a), n = n())
#> # A tibble: 1 x 3
#>    mean   sum     n
#>   <dbl> <int> <int>
#> 1     3    15     5

summarise(df, mean = mean(a * b), sum = sum(a * b), n = n())
#> # A tibble: 1 x 3
#>    mean   sum     n
#>   <dbl> <int> <int>
#> 1   9.6    48     5
```

Let's try it in galaaz:

```{ruby summarize_method}
def my_summarise2(df, expr)
  df.summarize(
    mean: E.mean(expr),
    sum: E.sum(expr),
    n: E.n
  )
end

puts my_summarise2((~:df), :a)
puts my_summarise2((~:df), :a * :b)
```

Once again, there is no need to use any special theory or functions.  The only point to be 
careful about is the use of 'E' to build an expression that uses the mean, sum and n.

# Different input and output variable

Now the next challenge presented by Hardley is to vary the name of the output variables based on 
the received expression.  So, if the input expression is 'a', we want our data frame columns to
be named 'mean\_a' and 'sum\_a'.  Now, if the input expression is 'b', columns
should be named 'mean\_b' and 'sum\_b'.

```
mutate(df, mean_a = mean(a), sum_a = sum(a))
#> # A tibble: 5 x 6
#>      g1    g2     a     b mean_a sum_a
#>   <dbl> <dbl> <int> <int>  <dbl> <int>
#> 1     1     1     1     3      3    15
#> 2     1     2     4     2      3    15
#> 3     2     1     2     1      3    15
#> 4     2     2     5     4      3    15
#> # … with 1 more row

mutate(df, mean_b = mean(b), sum_b = sum(b))
#> # A tibble: 5 x 6
#>      g1    g2     a     b mean_b sum_b
#>   <dbl> <dbl> <int> <int>  <dbl> <int>
#> 1     1     1     1     3      3    15
#> 2     1     2     4     2      3    15
#> 3     2     1     2     1      3    15
#> 4     2     2     5     4      3    15
#> # … with 1 more row
```

Here is our Ruby code

```{ruby name_change}
def my_mutate(df, expr)
  mean_name = "mean_#{expr.to_s}"
  sum_name = "sum_#{expr.to_s}"

  df.mutate(mean_name => E.mean(expr),
            sum_name => E.sum(expr))
end

puts my_mutate((~:df), :a)
puts my_mutate((~:df), :b)
```
It really seems that "Non Standard Evaluation" is actually quite standard in Galaaz! But, you 
might have noticed a small change in the way the arguments to the mutate method were called.
In a previous example we used df.summarise(mean: E.mean(:a), ...) where the column name was
followed by a ':' colom.  In this example, we have df.mutate(mean_name => E.mean(expr), ...)
and variable mean\_name is not followed by ':' but by '=>'.  This is standard Ruby notation.

[explain....]

# Capturing multiple variables

```{ruby multiple_vars}
def my_summarise3(df, *group_vars)
  df.group_by(*group_vars).
    summarise(a: E.mean(:a))
end

puts my_summarise3((~:df), :g1, :g2).as__data__frame
```

# Advanced dplyr features
https://www.r-bloggers.com/programming-with-dplyr-by-using-dplyr/

```{ruby starwars}
puts (~:starwars).head.as__data__frame
```

```{r grouped_mean}
grouped_mean <- function(data, grouping_variables, value_variables) {
  data %>%
    group_by_at(grouping_variables) %>%
    mutate(count = n()) %>%
    summarise_at(c(value_variables, "count"), mean, na.rm = TRUE) %>%
    rename_at(value_variables, funs(paste0("mean_", .)))
    }

gm = starwars %>% 
   grouped_mean("eye_color", c("mass", "birth_year"))

as.data.frame(gm)   
```
