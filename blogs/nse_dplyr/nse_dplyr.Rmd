---
title: "Non Standard Evaluation in dplyr with Galaaz"
author:
    - "Rodrigo Botafogo"
    - "Daniel Moss√© - University of Pittsburgh"
tags: [Tech, Data Science, Ruby, R, GraalVM]
date: "20/02/2019"
output:
  html_document:
    self_contained: true
    keep_md: true
  pdf_document:
    includes:
      in_header: ["../../sty/galaaz.sty"]
    number_sections: yes
---

```{r setup, echo=FALSE, message = FALSE}
library('dplyr')
library('tibble')
```

# Introduction

```{r tibble}
df <- data.frame(x = 1:3, y = 3:1)
print(df)

print(filter(df, x == 1))
#> # A tibble: 1 x 2
#>       x     y
#>   <int> <int>
#> 1     1     3
```

```{r my_var_err, eval = FALSE}
my_var <- x
#> Error in eval(expr, envir, enclos): object 'x' not found
filter(df, my_var == 1)
#> Error: object 'my_var' not found
```

```{ruby df}
@df = R.data__frame(x: (1..3), y: (3..1))
puts @df

puts @df.filter(:x.eq 1)
```

```{ruby my_var}
my_var = :x
puts @df.filter(my_var.eq 1)
```

> dplyr code is ambiguous. Depending on what variables are defined where, 
> filter(df, x == y) could be equivalent to any of:

```
df[df$x == df$y, ]
df[df$x == y, ]
df[x == df$y, ]
df[x == y, ]
```

In galaaz this ambiguity does not exist

```{ruby disamb}
y = 2
x = 2

puts @df[:x.eq :y, :all]
puts @df[:x.eq y, :all]
# @df[x.eq :y, :all]
# @df[x == y, :all]
```
